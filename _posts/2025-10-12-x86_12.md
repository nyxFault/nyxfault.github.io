---
title: "11. Shift and Rotate Instructions"
categories: [Programming, x86-64 Assembly]
tags: [Assembly, x86, x86-64]
---

Shift and rotate instructions are powerful bit manipulation operations that are faster than multiplication and division for powers of two. They allow you to move bits within registers, performing efficient arithmetic and logical operations.


These instructions move bits left or right within a register:

- **Shifts**: Bits moved out are lost, new bits filled based on shift type
- **Rotates**: Bits moved out are wrapped around to the other end

### Logical Shift Instructions

#### 1. SHL - Shift Left

**Syntax:** `SHL destination, count`

**How it works:**

- Shifts bits left by specified count
- Rightmost bits filled with zeros
- Leftmost bits shifted out go into Carry Flag (CF)

```s
; Binary: 00001011 (11 decimal)
mov al, 0b00001011
shl al, 1           ; AL = 00010110 (22 decimal)
shl al, 2           ; AL = 01011000 (88 decimal)

; Equivalent to multiplication by 2^n
mov eax, 5
shl eax, 2          ; EAX = 5 x (2^2) = 5 × 4 = 20
```

#### 2. SHR - Shift Right (Logical)

**Syntax:** `SHR destination, count`

**How it works:**

- Shifts bits right by specified count
- Leftmost bits filled with zeros
- Rightmost bits shifted out go into Carry Flag (CF)


```s
; Binary: 10101000 (168 decimal)
mov al, 0b10101000
shr al, 1           ; AL = 01010100 (84 decimal)
shr al, 2           ; AL = 00010101 (21 decimal)

; Equivalent to unsigned division by 2^n
mov eax, 20
shr eax, 2          ; EAX = 20 ÷ (2^2) = 20 ÷ 4 = 5
```

#### Arithmetic Shift Instructions

#### 3. SAL - Shift Arithmetic Left

**Syntax:** `SAL destination, count`

**How it works:**

- Identical to SHL
- Preserves sign bit for signed numbers

```s
mov eax, -10        ; Signed: -10
sal eax, 1          ; EAX = -20 (preserves sign)
```

#### 4. SAR - Shift Arithmetic Right

**Syntax:** `SAR destination, count`

**How it works:**

- Shifts bits right while preserving the sign bit
- Leftmost bits filled with the original sign bit
- Rightmost bits shifted out go into Carry Flag (CF)

```s
; Positive number
mov eax, 20
sar eax, 1          ; EAX = 10

; Negative number  
mov eax, -20        ; Binary: 11111111111111111111111111101100
sar eax, 1          ; EAX = -10 (preserves sign)
sar eax, 2          ; EAX = -5
```


#### Rotate Instructions

#### 5. ROL - Rotate Left

**Syntax:** `ROL destination, count`

**How it works:**

- Bits shifted left, bits shifted out wrap around to right
- Carry Flag contains the last bit shifted out


```s
; Binary: 10010011 (147 decimal)
mov al, 0b10010011
rol al, 1           ; AL = 00100111 (CF = 1)
rol al, 2           ; AL = 10011100 (CF = 0, CF = 0)
```

#### 6. ROR - Rotate Right

**Syntax:** `ROR destination, count`

**How it works:**

- Bits shifted right, bits shifted out wrap around to left
- Carry Flag contains the last bit shifted out

```s
; Binary: 10010011 (147 decimal)
mov al, 0b10010011
ror al, 1           ; AL = 11001001 (CF = 1)
ror al, 2           ; AL = 01100100 (CF = 1, CF = 0)
```


#### Rotate Through Carry Instructions

#### 7. RCL - Rotate Left Through Carry

**Syntax:** `RCL destination, count`

**How it works:**

- Rotates through Carry Flag
- CF becomes part of the rotation

```s
; AL = 10110010, CF = 0
mov al, 0b10110010
clc                 ; Clear Carry (CF = 0)
rcl al, 1           ; AL = 01100100, CF = 1
```

*NOTE*

The `CLC` instruction in x86 assembly stands for Clear Carry Flag. Its sole purpose is to set the Carry Flag (CF) in the EFLAGS register to 0.

#### 8. RCR - Rotate Right Through Carry

**Syntax:** `RCR destination, count`

**How it works:**

- Rotates through Carry Flag
- CF becomes part of the rotation

```s
; AL = 10110010, CF = 1
mov al, 0b10110010
stc                 ; Set Carry (CF = 1)
rcr al, 1           ; AL = 11011001, CF = 0
```

The x86 `STC` instruction stands for "Set Carry Flag." Its purpose is to unconditionally set the Carry Flag (CF) in the EFLAGS register to 1.


Let's get hands on some examples which will help in understanding this -

**Example 1: Fast Multiplication and Division**

```s
; Multiply by 8 (2^3)
mov eax, 7
shl eax, 3          ; EAX = 7 × 8 = 56

; Divide by 4 (2^2)
mov ebx, 20
shr ebx, 2          ; EBX = 20 ÷ 4 = 5 (unsigned)
sar ebx, 2          ; EBX = -20 ÷ 4 = -5 (signed)
```

**Example 2: Bit Field Extraction**

```s
; Extract bits 5-8 from a 32-bit value
mov eax, 0x12345678

; Binary representation of 0x12345678: 00010010 00110100 01010110 01111000

shr eax, 5          ; Shift bits 5-8 to positions 0-3
and eax, 0x0F       ; Mask to keep only lower 4 bits
; EAX now contains bits 5-8 of original value
```

**Example 3: Bit Manipulation**

```s
; Set bit 3
mov eax, 0
or eax, 1 << 3      ; EAX = 00001000

; Clear bit 3
mov ebx, 0xFF
and ebx, ~(1 << 3)  ; EBX = 11110111

; Toggle bit 3
mov ecx, 0x0A
xor ecx, 1 << 3     ; ECX = 00000010 → 00001010
```

**Example 4: Endianness Conversion**

```s
; Convert little-endian to big-endian (32-bit)
mov eax, 0x12345678
bswap eax           ; EAX = 0x78563412

; Alternative using shifts and rotates:
mov eax, 0x12345678
rol ax, 8           ; Rotate lower 16 bits
rol eax, 16         ; Rotate entire 32 bits
rol ax, 8           ; Rotate lower 16 bits again
```

The `BSWAP` instruction in x86/x64 assembly language performs a byte swap operation on a 32-bit or 64-bit general-purpose register. This instruction reverses the order of bytes within the specified register, effectively converting data between little-endian and big-endian formats or vice versa.

#### Flags Affected

All shift and rotate instructions affect flags:

- **CF**: Contains the last bit shifted out
- **OF**: Set if sign bit changes (only for single shifts)
- **SF**: Set if result is negative
- **ZF**: Set if result is zero
- **PF**: Set if result has even parity


**Next Up:** We'll explore **String Instructions** - specialized operations for efficient string and memory block processing!
